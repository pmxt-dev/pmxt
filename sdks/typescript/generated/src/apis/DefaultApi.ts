/* tslint:disable */
/* eslint-disable */
/**
 * PMXT Sidecar API
 * A unified local sidecar API for prediction markets (Polymarket, Kalshi, Limitless). This API acts as a JSON-RPC-style gateway. Each endpoint corresponds to a specific method on the generic exchange implementation. 
 *
 * The version of the OpenAPI document: 0.4.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BaseResponse,
  CancelOrderRequest,
  CreateOrder200Response,
  CreateOrderRequest,
  FetchBalance200Response,
  FetchEvents200Response,
  FetchEventsRequest,
  FetchMarkets200Response,
  FetchMarketsRequest,
  FetchOHLCV200Response,
  FetchOHLCVRequest,
  FetchOpenOrders200Response,
  FetchOpenOrdersRequest,
  FetchOrderBook200Response,
  FetchOrderBookRequest,
  FetchPositions200Response,
  FetchPositionsRequest,
  FetchTrades200Response,
  FetchTradesRequest,
  FilterEventsRequest,
  FilterMarketsRequest,
  GetExecutionPrice200Response,
  GetExecutionPriceDetailed200Response,
  GetExecutionPriceRequest,
  HealthCheck200Response,
  WatchOrderBookRequest,
  WatchPricesRequest,
  WatchTradesRequest,
  WatchUserPositionsRequest,
} from '../models/index';
import {
    BaseResponseFromJSON,
    BaseResponseToJSON,
    CancelOrderRequestFromJSON,
    CancelOrderRequestToJSON,
    CreateOrder200ResponseFromJSON,
    CreateOrder200ResponseToJSON,
    CreateOrderRequestFromJSON,
    CreateOrderRequestToJSON,
    FetchBalance200ResponseFromJSON,
    FetchBalance200ResponseToJSON,
    FetchEvents200ResponseFromJSON,
    FetchEvents200ResponseToJSON,
    FetchEventsRequestFromJSON,
    FetchEventsRequestToJSON,
    FetchMarkets200ResponseFromJSON,
    FetchMarkets200ResponseToJSON,
    FetchMarketsRequestFromJSON,
    FetchMarketsRequestToJSON,
    FetchOHLCV200ResponseFromJSON,
    FetchOHLCV200ResponseToJSON,
    FetchOHLCVRequestFromJSON,
    FetchOHLCVRequestToJSON,
    FetchOpenOrders200ResponseFromJSON,
    FetchOpenOrders200ResponseToJSON,
    FetchOpenOrdersRequestFromJSON,
    FetchOpenOrdersRequestToJSON,
    FetchOrderBook200ResponseFromJSON,
    FetchOrderBook200ResponseToJSON,
    FetchOrderBookRequestFromJSON,
    FetchOrderBookRequestToJSON,
    FetchPositions200ResponseFromJSON,
    FetchPositions200ResponseToJSON,
    FetchPositionsRequestFromJSON,
    FetchPositionsRequestToJSON,
    FetchTrades200ResponseFromJSON,
    FetchTrades200ResponseToJSON,
    FetchTradesRequestFromJSON,
    FetchTradesRequestToJSON,
    FilterEventsRequestFromJSON,
    FilterEventsRequestToJSON,
    FilterMarketsRequestFromJSON,
    FilterMarketsRequestToJSON,
    GetExecutionPrice200ResponseFromJSON,
    GetExecutionPrice200ResponseToJSON,
    GetExecutionPriceDetailed200ResponseFromJSON,
    GetExecutionPriceDetailed200ResponseToJSON,
    GetExecutionPriceRequestFromJSON,
    GetExecutionPriceRequestToJSON,
    HealthCheck200ResponseFromJSON,
    HealthCheck200ResponseToJSON,
    WatchOrderBookRequestFromJSON,
    WatchOrderBookRequestToJSON,
    WatchPricesRequestFromJSON,
    WatchPricesRequestToJSON,
    WatchTradesRequestFromJSON,
    WatchTradesRequestToJSON,
    WatchUserPositionsRequestFromJSON,
    WatchUserPositionsRequestToJSON,
} from '../models/index';

export interface CancelOrderOperationRequest {
    exchange: CancelOrderOperationExchangeEnum;
    cancelOrderRequest?: CancelOrderRequest;
}

export interface CloseRequest {
    exchange: CloseExchangeEnum;
    watchUserPositionsRequest?: WatchUserPositionsRequest;
}

export interface CreateOrderOperationRequest {
    exchange: CreateOrderOperationExchangeEnum;
    createOrderRequest?: CreateOrderRequest;
}

export interface FetchBalanceRequest {
    exchange: FetchBalanceExchangeEnum;
    fetchPositionsRequest?: FetchPositionsRequest;
}

export interface FetchEventsOperationRequest {
    exchange: FetchEventsOperationExchangeEnum;
    fetchEventsRequest?: FetchEventsRequest;
}

export interface FetchMarketsOperationRequest {
    exchange: FetchMarketsOperationExchangeEnum;
    fetchMarketsRequest?: FetchMarketsRequest;
}

export interface FetchOHLCVOperationRequest {
    exchange: FetchOHLCVOperationExchangeEnum;
    fetchOHLCVRequest?: FetchOHLCVRequest;
}

export interface FetchOpenOrdersOperationRequest {
    exchange: FetchOpenOrdersOperationExchangeEnum;
    fetchOpenOrdersRequest?: FetchOpenOrdersRequest;
}

export interface FetchOrderRequest {
    exchange: FetchOrderExchangeEnum;
    cancelOrderRequest?: CancelOrderRequest;
}

export interface FetchOrderBookOperationRequest {
    exchange: FetchOrderBookOperationExchangeEnum;
    fetchOrderBookRequest?: FetchOrderBookRequest;
}

export interface FetchPositionsOperationRequest {
    exchange: FetchPositionsOperationExchangeEnum;
    fetchPositionsRequest?: FetchPositionsRequest;
}

export interface FetchTradesOperationRequest {
    exchange: FetchTradesOperationExchangeEnum;
    fetchTradesRequest?: FetchTradesRequest;
}

export interface FilterEventsOperationRequest {
    exchange: FilterEventsOperationExchangeEnum;
    filterEventsRequest?: FilterEventsRequest;
}

export interface FilterMarketsOperationRequest {
    exchange: FilterMarketsOperationExchangeEnum;
    filterMarketsRequest?: FilterMarketsRequest;
}

export interface GetExecutionPriceOperationRequest {
    exchange: GetExecutionPriceOperationExchangeEnum;
    getExecutionPriceRequest?: GetExecutionPriceRequest;
}

export interface GetExecutionPriceDetailedRequest {
    exchange: GetExecutionPriceDetailedExchangeEnum;
    getExecutionPriceRequest?: GetExecutionPriceRequest;
}

export interface WatchOrderBookOperationRequest {
    exchange: WatchOrderBookOperationExchangeEnum;
    watchOrderBookRequest?: WatchOrderBookRequest;
}

export interface WatchPricesOperationRequest {
    exchange: WatchPricesOperationExchangeEnum;
    watchPricesRequest?: WatchPricesRequest;
}

export interface WatchTradesOperationRequest {
    exchange: WatchTradesOperationExchangeEnum;
    watchTradesRequest?: WatchTradesRequest;
}

export interface WatchUserPositionsOperationRequest {
    exchange: WatchUserPositionsOperationExchangeEnum;
    watchUserPositionsRequest?: WatchUserPositionsRequest;
}

export interface WatchUserTransactionsRequest {
    exchange: WatchUserTransactionsExchangeEnum;
    watchUserPositionsRequest?: WatchUserPositionsRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Cancel Order
     */
    async cancelOrderRaw(requestParameters: CancelOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateOrder200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling cancelOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/cancelOrder`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CancelOrderRequestToJSON(requestParameters['cancelOrderRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateOrder200ResponseFromJSON(jsonValue));
    }

    /**
     * Cancel Order
     */
    async cancelOrder(requestParameters: CancelOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateOrder200Response> {
        const response = await this.cancelOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Close all WebSocket connections and cleanup resources. Call this when you\'re done streaming to properly release connections. 
     * Close WebSocket Connections
     */
    async closeRaw(requestParameters: CloseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponse>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling close().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/close`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WatchUserPositionsRequestToJSON(requestParameters['watchUserPositionsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseFromJSON(jsonValue));
    }

    /**
     * Close all WebSocket connections and cleanup resources. Call this when you\'re done streaming to properly release connections. 
     * Close WebSocket Connections
     */
    async close(requestParameters: CloseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponse> {
        const response = await this.closeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create Order
     */
    async createOrderRaw(requestParameters: CreateOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateOrder200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling createOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/createOrder`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateOrderRequestToJSON(requestParameters['createOrderRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateOrder200ResponseFromJSON(jsonValue));
    }

    /**
     * Create Order
     */
    async createOrder(requestParameters: CreateOrderOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateOrder200Response> {
        const response = await this.createOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Balance
     */
    async fetchBalanceRaw(requestParameters: FetchBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchBalance200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchBalance().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchBalance`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchPositionsRequestToJSON(requestParameters['fetchPositionsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchBalance200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Balance
     */
    async fetchBalance(requestParameters: FetchBalanceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchBalance200Response> {
        const response = await this.fetchBalanceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Events
     */
    async fetchEventsRaw(requestParameters: FetchEventsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchEvents200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchEvents().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchEvents`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchEventsRequestToJSON(requestParameters['fetchEventsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchEvents200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Events
     */
    async fetchEvents(requestParameters: FetchEventsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchEvents200Response> {
        const response = await this.fetchEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Markets
     */
    async fetchMarketsRaw(requestParameters: FetchMarketsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchMarkets200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchMarkets().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchMarkets`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchMarketsRequestToJSON(requestParameters['fetchMarketsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchMarkets200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Markets
     */
    async fetchMarkets(requestParameters: FetchMarketsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchMarkets200Response> {
        const response = await this.fetchMarketsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch OHLCV Candles
     */
    async fetchOHLCVRaw(requestParameters: FetchOHLCVOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchOHLCV200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchOHLCV().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchOHLCV`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchOHLCVRequestToJSON(requestParameters['fetchOHLCVRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchOHLCV200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch OHLCV Candles
     */
    async fetchOHLCV(requestParameters: FetchOHLCVOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchOHLCV200Response> {
        const response = await this.fetchOHLCVRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Open Orders
     */
    async fetchOpenOrdersRaw(requestParameters: FetchOpenOrdersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchOpenOrders200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchOpenOrders().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchOpenOrders`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchOpenOrdersRequestToJSON(requestParameters['fetchOpenOrdersRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchOpenOrders200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Open Orders
     */
    async fetchOpenOrders(requestParameters: FetchOpenOrdersOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchOpenOrders200Response> {
        const response = await this.fetchOpenOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Order
     */
    async fetchOrderRaw(requestParameters: FetchOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateOrder200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchOrder`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CancelOrderRequestToJSON(requestParameters['cancelOrderRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateOrder200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Order
     */
    async fetchOrder(requestParameters: FetchOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateOrder200Response> {
        const response = await this.fetchOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Order Book
     */
    async fetchOrderBookRaw(requestParameters: FetchOrderBookOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchOrderBook200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchOrderBook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchOrderBook`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchOrderBookRequestToJSON(requestParameters['fetchOrderBookRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchOrderBook200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Order Book
     */
    async fetchOrderBook(requestParameters: FetchOrderBookOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchOrderBook200Response> {
        const response = await this.fetchOrderBookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Positions
     */
    async fetchPositionsRaw(requestParameters: FetchPositionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchPositions200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchPositions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchPositions`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchPositionsRequestToJSON(requestParameters['fetchPositionsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchPositions200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Positions
     */
    async fetchPositions(requestParameters: FetchPositionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchPositions200Response> {
        const response = await this.fetchPositionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch Trades
     */
    async fetchTradesRaw(requestParameters: FetchTradesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchTrades200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling fetchTrades().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/fetchTrades`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FetchTradesRequestToJSON(requestParameters['fetchTradesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchTrades200ResponseFromJSON(jsonValue));
    }

    /**
     * Fetch Trades
     */
    async fetchTrades(requestParameters: FetchTradesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchTrades200Response> {
        const response = await this.fetchTradesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Filter a list of events by criteria. Can filter by string query, structured criteria object, or custom filter function. 
     * Filter Events
     */
    async filterEventsRaw(requestParameters: FilterEventsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchEvents200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling filterEvents().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/filterEvents`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FilterEventsRequestToJSON(requestParameters['filterEventsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchEvents200ResponseFromJSON(jsonValue));
    }

    /**
     * Filter a list of events by criteria. Can filter by string query, structured criteria object, or custom filter function. 
     * Filter Events
     */
    async filterEvents(requestParameters: FilterEventsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchEvents200Response> {
        const response = await this.filterEventsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Filter a list of markets by criteria. Can filter by string query, structured criteria object, or custom filter function. 
     * Filter Markets
     */
    async filterMarketsRaw(requestParameters: FilterMarketsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchMarkets200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling filterMarkets().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/filterMarkets`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FilterMarketsRequestToJSON(requestParameters['filterMarketsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchMarkets200ResponseFromJSON(jsonValue));
    }

    /**
     * Filter a list of markets by criteria. Can filter by string query, structured criteria object, or custom filter function. 
     * Filter Markets
     */
    async filterMarkets(requestParameters: FilterMarketsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchMarkets200Response> {
        const response = await this.filterMarketsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Execution Price
     */
    async getExecutionPriceRaw(requestParameters: GetExecutionPriceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExecutionPrice200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling getExecutionPrice().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/getExecutionPrice`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetExecutionPriceRequestToJSON(requestParameters['getExecutionPriceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetExecutionPrice200ResponseFromJSON(jsonValue));
    }

    /**
     * Get Execution Price
     */
    async getExecutionPrice(requestParameters: GetExecutionPriceOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExecutionPrice200Response> {
        const response = await this.getExecutionPriceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Detailed Execution Price
     */
    async getExecutionPriceDetailedRaw(requestParameters: GetExecutionPriceDetailedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetExecutionPriceDetailed200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling getExecutionPriceDetailed().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/getExecutionPriceDetailed`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetExecutionPriceRequestToJSON(requestParameters['getExecutionPriceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetExecutionPriceDetailed200ResponseFromJSON(jsonValue));
    }

    /**
     * Get Detailed Execution Price
     */
    async getExecutionPriceDetailed(requestParameters: GetExecutionPriceDetailedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetExecutionPriceDetailed200Response> {
        const response = await this.getExecutionPriceDetailedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Server Health Check
     */
    async healthCheckRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthCheck200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/health`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthCheck200ResponseFromJSON(jsonValue));
    }

    /**
     * Server Health Check
     */
    async healthCheck(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthCheck200Response> {
        const response = await this.healthCheckRaw(initOverrides);
        return await response.value();
    }

    /**
     * Subscribe to real-time order book updates via WebSocket. Returns a promise that resolves with the next order book update. Call repeatedly in a loop to stream updates (CCXT Pro pattern). 
     * Watch Order Book (WebSocket Stream)
     */
    async watchOrderBookRaw(requestParameters: WatchOrderBookOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchOrderBook200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling watchOrderBook().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/watchOrderBook`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WatchOrderBookRequestToJSON(requestParameters['watchOrderBookRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchOrderBook200ResponseFromJSON(jsonValue));
    }

    /**
     * Subscribe to real-time order book updates via WebSocket. Returns a promise that resolves with the next order book update. Call repeatedly in a loop to stream updates (CCXT Pro pattern). 
     * Watch Order Book (WebSocket Stream)
     */
    async watchOrderBook(requestParameters: WatchOrderBookOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchOrderBook200Response> {
        const response = await this.watchOrderBookRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch Prices (WebSocket Stream)
     */
    async watchPricesRaw(requestParameters: WatchPricesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponse>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling watchPrices().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/watchPrices`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WatchPricesRequestToJSON(requestParameters['watchPricesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseFromJSON(jsonValue));
    }

    /**
     * Watch Prices (WebSocket Stream)
     */
    async watchPrices(requestParameters: WatchPricesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponse> {
        const response = await this.watchPricesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Subscribe to real-time trade updates via WebSocket. Returns a promise that resolves with the next trade(s). Call repeatedly in a loop to stream updates (CCXT Pro pattern). 
     * Watch Trades (WebSocket Stream)
     */
    async watchTradesRaw(requestParameters: WatchTradesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FetchTrades200Response>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling watchTrades().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/watchTrades`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WatchTradesRequestToJSON(requestParameters['watchTradesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FetchTrades200ResponseFromJSON(jsonValue));
    }

    /**
     * Subscribe to real-time trade updates via WebSocket. Returns a promise that resolves with the next trade(s). Call repeatedly in a loop to stream updates (CCXT Pro pattern). 
     * Watch Trades (WebSocket Stream)
     */
    async watchTrades(requestParameters: WatchTradesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FetchTrades200Response> {
        const response = await this.watchTradesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch User Positions (WebSocket Stream)
     */
    async watchUserPositionsRaw(requestParameters: WatchUserPositionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponse>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling watchUserPositions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/watchUserPositions`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WatchUserPositionsRequestToJSON(requestParameters['watchUserPositionsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseFromJSON(jsonValue));
    }

    /**
     * Watch User Positions (WebSocket Stream)
     */
    async watchUserPositions(requestParameters: WatchUserPositionsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponse> {
        const response = await this.watchUserPositionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Watch User Transactions (WebSocket Stream)
     */
    async watchUserTransactionsRaw(requestParameters: WatchUserTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseResponse>> {
        if (requestParameters['exchange'] == null) {
            throw new runtime.RequiredError(
                'exchange',
                'Required parameter "exchange" was null or undefined when calling watchUserTransactions().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/{exchange}/watchUserTransactions`;
        urlPath = urlPath.replace(`{${"exchange"}}`, encodeURIComponent(String(requestParameters['exchange'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WatchUserPositionsRequestToJSON(requestParameters['watchUserPositionsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BaseResponseFromJSON(jsonValue));
    }

    /**
     * Watch User Transactions (WebSocket Stream)
     */
    async watchUserTransactions(requestParameters: WatchUserTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseResponse> {
        const response = await this.watchUserTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CancelOrderOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type CancelOrderOperationExchangeEnum = typeof CancelOrderOperationExchangeEnum[keyof typeof CancelOrderOperationExchangeEnum];
/**
 * @export
 */
export const CloseExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type CloseExchangeEnum = typeof CloseExchangeEnum[keyof typeof CloseExchangeEnum];
/**
 * @export
 */
export const CreateOrderOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type CreateOrderOperationExchangeEnum = typeof CreateOrderOperationExchangeEnum[keyof typeof CreateOrderOperationExchangeEnum];
/**
 * @export
 */
export const FetchBalanceExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchBalanceExchangeEnum = typeof FetchBalanceExchangeEnum[keyof typeof FetchBalanceExchangeEnum];
/**
 * @export
 */
export const FetchEventsOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchEventsOperationExchangeEnum = typeof FetchEventsOperationExchangeEnum[keyof typeof FetchEventsOperationExchangeEnum];
/**
 * @export
 */
export const FetchMarketsOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchMarketsOperationExchangeEnum = typeof FetchMarketsOperationExchangeEnum[keyof typeof FetchMarketsOperationExchangeEnum];
/**
 * @export
 */
export const FetchOHLCVOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchOHLCVOperationExchangeEnum = typeof FetchOHLCVOperationExchangeEnum[keyof typeof FetchOHLCVOperationExchangeEnum];
/**
 * @export
 */
export const FetchOpenOrdersOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchOpenOrdersOperationExchangeEnum = typeof FetchOpenOrdersOperationExchangeEnum[keyof typeof FetchOpenOrdersOperationExchangeEnum];
/**
 * @export
 */
export const FetchOrderExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchOrderExchangeEnum = typeof FetchOrderExchangeEnum[keyof typeof FetchOrderExchangeEnum];
/**
 * @export
 */
export const FetchOrderBookOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchOrderBookOperationExchangeEnum = typeof FetchOrderBookOperationExchangeEnum[keyof typeof FetchOrderBookOperationExchangeEnum];
/**
 * @export
 */
export const FetchPositionsOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchPositionsOperationExchangeEnum = typeof FetchPositionsOperationExchangeEnum[keyof typeof FetchPositionsOperationExchangeEnum];
/**
 * @export
 */
export const FetchTradesOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FetchTradesOperationExchangeEnum = typeof FetchTradesOperationExchangeEnum[keyof typeof FetchTradesOperationExchangeEnum];
/**
 * @export
 */
export const FilterEventsOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FilterEventsOperationExchangeEnum = typeof FilterEventsOperationExchangeEnum[keyof typeof FilterEventsOperationExchangeEnum];
/**
 * @export
 */
export const FilterMarketsOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type FilterMarketsOperationExchangeEnum = typeof FilterMarketsOperationExchangeEnum[keyof typeof FilterMarketsOperationExchangeEnum];
/**
 * @export
 */
export const GetExecutionPriceOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type GetExecutionPriceOperationExchangeEnum = typeof GetExecutionPriceOperationExchangeEnum[keyof typeof GetExecutionPriceOperationExchangeEnum];
/**
 * @export
 */
export const GetExecutionPriceDetailedExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type GetExecutionPriceDetailedExchangeEnum = typeof GetExecutionPriceDetailedExchangeEnum[keyof typeof GetExecutionPriceDetailedExchangeEnum];
/**
 * @export
 */
export const WatchOrderBookOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type WatchOrderBookOperationExchangeEnum = typeof WatchOrderBookOperationExchangeEnum[keyof typeof WatchOrderBookOperationExchangeEnum];
/**
 * @export
 */
export const WatchPricesOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type WatchPricesOperationExchangeEnum = typeof WatchPricesOperationExchangeEnum[keyof typeof WatchPricesOperationExchangeEnum];
/**
 * @export
 */
export const WatchTradesOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type WatchTradesOperationExchangeEnum = typeof WatchTradesOperationExchangeEnum[keyof typeof WatchTradesOperationExchangeEnum];
/**
 * @export
 */
export const WatchUserPositionsOperationExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type WatchUserPositionsOperationExchangeEnum = typeof WatchUserPositionsOperationExchangeEnum[keyof typeof WatchUserPositionsOperationExchangeEnum];
/**
 * @export
 */
export const WatchUserTransactionsExchangeEnum = {
    Polymarket: 'polymarket',
    Kalshi: 'kalshi',
    Limitless: 'limitless'
} as const;
export type WatchUserTransactionsExchangeEnum = typeof WatchUserTransactionsExchangeEnum[keyof typeof WatchUserTransactionsExchangeEnum];
